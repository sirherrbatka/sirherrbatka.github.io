* Android
** activity                                                        :activity:
*** reprezentuje pojedynczy ekran zawierający interfej użytkownika
*** deklarowana w manifeście
*** koniecznie utworzenie obiektu intent                             :intent:
**** ważne dla interakcji pomiędzy aplikacjami
*** tworzenie i startowanie                                       :important:
**** tworzenie intent                                                :intent:
***** Intent intent = new Intent(this, Activity.class);              :intent:
**** uruchomienie activity
***** startActivity(intent)
***** startActivityForResult(intent)
****** analog okienka dialogowe (mniej więcej)
****** ponieważ java to choroba, jest to dziwne
******* Intent intent = new Intent(this, GroupActivity.class);
******* startActivityForResult(intent, CODE_ADD_GROUP_ACTIVITY);
******* przy powrocie wywołanie onActivityResult(int reqCode, int resCode, Intent i)
******** TODO reqCode
******** resCode
********* status wyniku (powodzenie == RESULT_OK)
**** Dodatkowe informacje przekazywane w intent
***** intent.putExtra("MAX_VALUE", 123);
*** cykl życia                                               :important:easy:
**** listenery
***** uruchomienie
****** onCreate()
******* przy tworzenie activity
******* inicjalizacja wszystkiego
****** onStart()
******* Wywołana przed wyświetleniem
****** onResume()
******* Wywołana przed rozpoczęciem interakcji
***** zmiana activity
****** onPause (dla aktywności ukrywanej)
******* Zapisanie danych, zatrzymanie działań.
****** onResume() (dla aktywności pokazywanej)
***** zatrzymanie activity
****** onStop()
******* Wywoływane gdy activity przestaje być widoczne.
***** Wznawianie zatrzymanej activity
****** onRestart()
****** onStart()
****** onResume()
***** Niszczenie activity
****** onStop() (wipierw zostanie zatrzymana i ukryta)
****** onDestroy() (następnie
** DONE Przechowywanie danych                                :important:easy:
   CLOSED: [2018-01-23 wto 19:15]
*** dla activity
**** przed przejściem activity do zniszczenia wywoływany jest callback onSaveInstanceState(Bundle bundle)
**** Bundle pozwala na przechowywanie stanu.
**** podczas przywracania wywoływane jest onRestoreInstanceState(Bundle bundle)
**** bundle przekazywane jest też do onCreate
**** istnieje też parcalable, ale nie należy go używać do przechowywania danych a jedynie do IPC
** DONE Activity i fragmenty                                      :important:
   CLOSED: [2018-01-24 śro 07:54]
*** fragmenty
**** reprezentują zachowanie części interfejsu w activity
**** mogą być wykorzystane ponownie w wielu activity
**** mogą być użyte w większej liczbie w jednym activity
**** posiada własny cykl życia
**** musi siedzieć w activity, ponieważ niczym u tasiemca, jego cykl życia jest powiązany z cyklem activity
**** gdy activity jeż działa (w stanie resumed) można swodobnie dodawać i usuwać fragmenty
**** tworzenie
***** subklasa Fragment
***** kod zbliżony do activity
****** onCreate
****** onStart
****** onPause
****** onStop
***** wbudowane fragmenty
****** DialogFragment
****** ListFragment
****** PreferenceFragmentCompat
***** ładowanie layoutu
       public static class ExampleFragment extends Fragment {
       @Override
       public View onCreateView(LayoutInflater inflater, ViewGroup container,
                                Bundle savedInstanceState) {
          // Inflate the layout for this fragment
          return inflater.inflate(R.layout.example_fragment, container, false);
          }
       }
****** argumenty inflate
******* ID
******* ViewGroup (rodzic)
******* boolean, informacja o tym czy fragment ma zostać dołączony do grupy w trakcie inflacji
***** dodawanie do aktywności
****** dodaj do pliku layoutu
****** ewentualnie można zrobić to programistycznie
******* FragmentManager fragmentManager = getSupportFragmentManager(); FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();
******* ExampleFragment fragment = new ExampleFragment();
        fragmentTransaction.add(R.id.fragment_container, fragment); //pierwszy argument to ViewGroup do którego ma zostać dodany fragment
        fragmentTransaction.addToBackStack(fragment);
        fragmentTransaction.commit();
****** pobranie activity
******* metoda call activity
****** pobranie dodanego fragmentu
******* ExampleFragment fragment = (ExampleFragment) getFragmentManager().findFragmentById(R.id.example_fragment);
** DONE Czujniki i ich wykorzystanie                              :important:
   CLOSED: [2018-01-23 wto 18:38]
*** Zgodnie z https://developer.android.com/guide/topics/sensors/sensors_overview.html
*** Typy
    | sensor                   | typ               | a co to robi?                                            |
    |--------------------------+-------------------+----------------------------------------------------------|
    | TYPE_ACCELEROMETER       | hardware          | przyśpieszenie w m/s^2 włącznie z siłą grawitacji        |
    | TYPE_AMBIENT_TEMPERATURE | hardware          | temperatura w stopniach Celsjusza                        |
    | TYPE_GRAVITY             | software/hardware | przyśpieszenie w m/s^2                                   |
    | TYPE_GYROSCOPE           | software/hardware | mierzy rotację we wszystkich osiach                      |
    | TYPE_LIGHT               | hardware          | światło w lx                                             |
    | TYPE_LINEAR_ACCELERATION | software/hardware | akcelerometr, pomija siłę grawitacji                     |
    | TYPE_MAGNETIC_FIELD      | hardware          | polę geomagnetyczne we wszystkich osiach w mikro Teslach |
    | TYPE_ORIENTATION         | software          | mierzy rotację. Potrafi obecnie zwrócić macierz rotacji. |
    | TYPE_PRESSURE            | hardware          | Mierzy ciśnienie w pascalach.                            |
    | TYPE_PROXIMITY           | hardware          | zbliżenie w cm od ekranu                                 |
    | TYPE_RELATIVE_HUMIDITY   | hardware          | wilgotność powietrza w %                                 |
    | TYPE_ROTATION_VECTOR     | software/hardware | W zasadzie to samo to orientacja?                        |
    | TYPE_TEMPERATURE         | hardware          | przestarzałe, używać TYPE_AMBIENT_TEMPERATURE            |
*** Czujniki ruhchu
**** mierzą siły wzdłuż trzech osi
**** akcelerometr
**** czujnik grawitacji
**** żyroskop
**** czujnik rotacji?
*** Czujniki pozycji
**** mierzą fizyczną pozycję urządzenia
**** czujnik orientacji (nie wiem jak ma działać)
**** magnetometr
*** czujniki środowiskowe
**** temperatura
**** ciśnienie
**** wilgotność i jaśność
*** Wykorzystanie
**** pobrać z SystemService SensorManager
**** pobrać z SensorManager instancję sensor
**** ((SensorManager)getSystemService(Context.SENSOR_SERVICE)).getDefaultSensor(Sensor.TYPE_ACCELEROMETER)...
**** List<Sensor> deviceSensors = mSensorManager.getSensorList(Sensor.TYPE_ALL) by zobaczyć jakie sensory są obecne.
**** można podłączyć się do sensora za pomocą SensorEventListener
**** SensorEvent
***** typ sensora
***** dokładność danych
***** timestamp
***** surowe dane
**** by korzystać z sensora potrzeba uprawnień.
** DONE Manifest i uprawnienia                               :important:easy:
   CLOSED: [2018-01-23 wto 19:08]
*** plik xml dostarcza informacje o aplikacji dla androida
*** zawiera
**** nazwa pakietu javy
**** opis komponentów aplikacji (activities, services, providers)
**** nazwy klas implementujące komponenty
**** procesy hostujące komponenty
**** deklarację uprawnień
**** wymagania odnośnie wersji
**** lista zależności (bibliotek)
*** uprawnienia
**** description (ludzki opis)
**** icon (obrazek)
**** label (ludzka nazwa)
**** name (nazwa kodowa)
**** permissionGroup (przypisanie uprawnienia do grupy)
**** protectionlevel
***** normal -- izolowany dostęp do funkcji apliakcji. Nie pyta użytkownika o zgodę.
***** dangerous -- dostęp do prywatnych danych. Może prosić o pozwolenie.
***** signature -- zezwala na dostęp aplikacjom podpisanym tym samym certyfikatem.
***** signatureOrSystem -- jak wyżej ale dodatkowo pozwala na dostęp aplikacjom systemowym.
** TODO Kwalifikatory i ich zastosowanie                          :important:
*** aplikacja ma zasoby w folderze ref
*** następnie zasoby są przepisane do podkatalogu
    | folder   | opis                                    |
    |----------+-----------------------------------------|
    | animator | P.XML typu property animations          |
    | anim     | P.XML typu tween animations             |
    | color    | P.XML definiuje listę kolorów           |
    | drawable | P.Bitmap                                |
    | mimap    | P. dla różnych gęstości ikon            |
    | layout   | P.XML definiuje layout                  |
    | menu     | P.XML definiuje menu                    |
    | raw      | P. do zapisu w raw formie               |
    | values   | Prote P. XML z string int colors arrays |
    | xml      | Pliki XML w ich środowisku              |
    | fonts    | Pliki czcionek                         |
*** https://developer.android.com/guide/topics/resources/providing-resources.html
** DONE Wątki i async task                                   :important:easy:
   CLOSED: [2018-01-24 śro 08:06]
*** Broń boże nie próbować blokować wątku GUI.
*** private class DownloadFilesTask extends AsyncTask<URL, Integer, Long> {
        protected Long doInBackground(URL... urls) {
             int count = urls.length;
             long totalSize = 0;
             for (int i = 0; i < count; i++) {
                 totalSize += Downloader.downloadFile(urls[i]);
                 publishProgress((int) ((i / (float) count) * 100));
                 // Escape early if cancel() is called
                 if (isCancelled()) break;
             }
             return totalSize;
          }

          protected void onProgressUpdate(Integer... progress) { //na wątku UI
              setProgressPercent(progress[0]);
          }

          protected void onPostExecute(Long result) { //na wątku UI
              showDialog("Downloaded " + result + " bytes");
          }
     }
*** new DownloadFilesTask().execute(url1, url2, url3);
*** dodatkowe metody
**** onCancelled()
**** onCancel()
**** onPreExecute
*** parametry generyczne:
**** co przyjmuje przy konstrukcji
**** co zwraca w ramach progress
**** co zwraca po wykonaniu
* iOS
** TODO Objective-C                                           :important:WTF:
*** Jeśli Objective-C to pytanie, odpowiedzią jest NIE.
** TODO Zarządzanie pamięcią w Objective-C                   :important:easy:
** DONE Podstawowe klasy systemowe (NSString, NSArray, NSDictionary, NSSet, ...) :important:easy:
   CLOSED: [2018-01-24 śro 07:57]
*** stringi
**** NSSstring -- niemutowalny string (UTF-16, możliwe utworzenie z UTF lub ascii)
**** NSMutableString -- mutowalny string (UTF-16, możliwe utworzenie z UTF lub ascii)
**** metody
***** compare
***** hash
***** isEqual
***** getCString
***** utf8String
***** length
***** write -- zapisz string do pliku (wtf?! why?).
*** array
**** NSArray -- stały, statyczny array
**** NSMutableArray -- dynamiczny array
***** dodatkowe metody
****** insert (rozsuń by zrobić miejsce, wsadź do środka)
****** add (dodaj na koniec)
**** NSPointerArray -- potrafi trzymać nil (yay!)
***** ma bardziej rozbudowane semantykę do obsługi pamięci (może być zainicjalizowane by trzymać weak pointery)
***** dodatkowe gówno-metody
****** insertPointer
****** addPointer
***** dodatkowo to co w mutable array
**** metody
***** count
***** contains
***** firstObject -- z początku array
***** lastObject -- na końcu array
***** subscript -- dereferencja elementu z array
***** index -- pozycja elementu w array
***** indexOfObject -- przyjmuje predykat, zwraca indeks pierwszego elementu dla którego predykat jest spełniony.
*** słowniki
**** mapuje stringi na obiekty
**** NSDictionary
**** NSMutableDictionary
***** dodatkowe metody
****** setValue
****** removeObject
**** metody
***** count
***** allKeys
***** allValues
***** value
*** sety
**** zbíór (obiekt albo w nim jest, albo go w nim nie ma).
**** NSSet
**** NSMutableSet
***** dodatkowe metody
****** union
****** minus
****** intersect
****** setSet
***** add
***** filter
***** remove
**** NSCountedSet
***** mutowalny set, pozwala na wielokrotne dodanie tego samego elementu
***** dodatkowe mestody
****** count
**** metody
***** contains
***** filtered (tworzy set na podstawie istniejącego, zawierający jedynie elementy dla których predykat zwraca true).
***** member -- zwraca obiekt jeśli jest zawarty w zbiorze.
***** interects
***** isSubset
** TODO CoreData.                                                 :important:
** TODO Storyboards.                                              :important:
** TODO Klasy mutable i non-mutable.                              :important:
** TODO AppStore Guidelines.                                      :important:
** TODO Wykorzystanie Instruments (profiler).                     :important:
** TODO Wykorzystanie symulatora.                             :important:WTF:
