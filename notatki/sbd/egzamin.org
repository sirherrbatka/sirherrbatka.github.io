* tworzenie indeksów
** create bitmap index normal_empno_bmx on test_normal(empno);
*** bitmap
** create index normal_empno_bmx on test_normal(empno);
*** btree
* używanie indeksów
** SELECT * FROM Table WITH(INDEX(Index_Name))
** SELECT NO_INDEX(t1 id1) FROM t1, t2 WHERE t1.id = t2.id;
* ORM
** hibernate
*** package com.ps2;

    import javax.faces.bean.ManagedBean;
    import javax.faces.bean.SessionScoped;
    import org.hibernate.Session;

    @ManagedBean
    @SessionScoped

    public class Data {
        private Publisher p;
        private HibernateUtil helper;
        private Session session;
        private String name;

        public String getName(){
            session = helper.getSessionFactory().openSession();
            session.beginTransaction();
            p = (Publisher) session.get(Publisher.class, 1); /*identyfikator wydawcy = 1*/
            this.name = p.getName();
            return name;
        }


        public void addPublisher(){
        p = new Publisher("Znak");
        session = helper.getSessionFactory().openSession();
        session.beginTransaction();
        session.save(p);
        session.getTransaction().commit();
        session.close();
        }

    }
* Czynniki wpływające na wydajność bazy danych
** budowa bazy
*** użycie kluczy głównych (wtf?)
*** użycie kluczy obcych
*** użycie indeksów
*** konstukcja tabel i ich relacji
** budowa zapytań SQL
*** konstrukcja zapytnia
*** złączenia
*** funkcje dodatkowe
*** wykorzystanie indeksów
** hardware
** konfiguracja
* ACID
** atomicity
** consistency
** isolation
** durability
* blokady DML
* CREATE TABLESPACE DATAFILE '\ORACLE1\ORACTP\data\oractp_ar01.dbf' SIZE 500M
  AUTOEXTEND ON NEXT 200M MAXSIZE 1024M
  DEFAULT STORAGE (INITIAL 10M NEXT 1M PCTINCREASE 10)
  EXTENT MANAGEMENT LOCAL UNIFORM SIZE 2M
  [MINIMUM EXTENT, maximum extent]
  PERMANENT
  ONLINE
  LOGGING;
* create table table_name(p1 int, p2 int) tablespace ts;
