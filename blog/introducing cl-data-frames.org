#+TITLE:       Introducing cl-data-frames
#+AUTHOR:
#+EMAIL:       shka@tuxls
#+DATE:        2019-09-25 Å›ro
#+URI:         /blog/%y/%m/%d/introducing-cl-data-frames
#+KEYWORDS:    lisp
#+TAGS:        lisp
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: Data frame library for the Common Lisp

* A little bit of background
The key feature of commonly used languages for data science and statistical analysis is the existence of data frames. Data frame is essentially just a way of presenting data in the form of the table, plus a set of operations allowing easy manipulation of the content. This probably does not sound all that thrilling at this point but once the domain is considered one quickly realizes that in practice almost every frequently performed task should be performed using a data frame. Don't get me wrong, It still can be done without one, but by sticking to the fundamental data structures you are simply wasting your time. Let's, for instance, consider a typical code written in R with the help of the ubiquitous Dplyr package.

We have a data frame containing data set with a human body type information: weight and height under the columns "weight" and "height". We decided to add a new column to the data frame with a body mass index (BMI for short, and that's how the new column will be called). To do so, we will simply need a single line of the code.

#+BEGIN_SRC R
transform(body_data_frame, bmi = weight / height^2)
#+END_SRC

You may be wondering: how does this even work? There is no lambda form to be found and the result of calling the transform is not stored anywhere. Dplyr makes good use of language features of the R: first-class expressions and the first-class environments. First-class expressions are somewhat like first-class functions, that is: just like some languages allow you to pass a function as an argument to the other function, R allows you to pass non-evaluated expression. The difference is that functions are embedded in the lexical environment which is augmented during the call by creating new bindings according to the lambda list of the function. Expressions are not called, they are just evaluated and R allows you to pass explicit environment where this will happen as well as facilities to programmatically construct environment during the runtime. Transform iterates row-wise over the whole frame, each time evaluating the passed expression in an environment containing additional bindings to the values in this row, under each column. After evaluation values can be accessed, manipulated and transfered to a new data frame. That is, new. Transform actually does not perform destructive manipulation of the existing data frame. Instead, it will mutate the caller environment to alter binding of the body_data_frame to the newly constructed data frame. This is a quite elegant solution!

Unfortunately, R is not ideal. Even after going up the steep initial learning curve of learning the essential packages you may find yourself limited. For instance: you may ask "where are the input/output streams?" and the answer is "there are none". R is a highly specialized language and lacks many of the general-purpose features that you may take for granted. This may not seem to be a problem initially, but eventually, you will find yourself attempting to represent sets of boolean flags as a bit-set for the efficiency sake. You will then realize that you won't be able to force any of the libraries you are using for such important tasks like clustering to work with your new data representation.

Python's pandas library is not nearly as nice to use. Spark's data frames even less so. Also, neither of those is lisp. Perhaps Julia is the right answer, but I am already in a deep romantic relationship with the Common Lisp. And not only that: there is a lot of practical merit in using Common Lisp in all sorts of interactive data processing tasks. But as already established I would prefer to do so using a data frames library, and so I decided to write one that would be pleasant to use.
