#+TITLE:       design of cl-data-structures aggregation protocol
#+AUTHOR:
#+EMAIL:       shka@tuxls
#+DATE:        2019-02-02 sob
#+URI:         /blog/%y/%m/%d/design-of-cl-data-structures-aggregation-protocol
#+KEYWORDS:    lisp, CLOS, object orientation
#+TAGS:        lisp, CLOS, object orientation
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: Mindset and reasoning behind cl-data-structures aggregation protocol.
* Background
The very first post I have published on this blog was describing what are cl-data-structures ranges. In this post I want to show how introduction of ranges allowed to build universal aggregation functions on top of them.

* What is aggregation function?
It is not so different from the SQL, really. Pretty much everything that is supposed to transform whole range of the values into single result can be considered to be any aggregation function so here comes your MAX, MIN, AVERAGE and so one. The usefullness of such functions shouldn't need explenation, but some of the design considerations are less obvious. First of it is important to note that aggregation functions don't have to work in the very same way on every data. SQL statement "select baz, MAX(foo) from bar GROUP BY baz" is a classical example demonstraiting this angle, but it is worth noting that idea can go further than that.

Statistical bootstraping is procedure of obtaining approximated estimator from distribution by sampling. Usual reason to do so is high (time and/or memory) complexity of calculation which would render procedure inpractical for large sets. Boostrapping procedure is usually somewhat independent from the specifics of the estimator, therefore it makes sense to have a way to establish boostrapping not in the aggregator itself, but allow boostrapping to use specific aggregator instead.

Next, we need to consider specific situations where aggregation can be terminated early, for instance because FIND function has found a specific value required number of times.

Finally, some aggregation functions require more then just one step. Examples include everything that requires sorting, which naturally includes MEDIAN and everything that includes median as intermidiate step.

* Mindset: Solve et coagula
Fundamentally any software architecture is just an excersise of skillfully dividing and combining parts of the problem in order to achieve various goals. Therefore since we have at least a vague understanding of goals and the problem itself, let's consider how to divide the problem in orderd to achieve the desired result.

1. We need a way to represent the values that are about to be aggregated. This clearly should be just a range as it fits description perfectly.
2. We need a way to invoke aggregation. Usual way to do so is to simply call a function with the proper argument. We will stick to it, because I think that this is type of the interface programmer would expect and want to use.
3. W need a way to control aggregation as described in the first paragraph. This is the least obvious part, and therefore it probabbly should be divided into more subproblems. Let's focus on this specifc part for the moment.

* Control flow
As Alan Kay would point out, criticial part of the object oriented programming is communication, and since (as already pointed out) essence of all software architectures is combining and dividing it stands to reason that one should to think how to control the aggregation by the means of the messages. It is usually a good idea to lay down design constraints of the messaging before deciding to move forward. I have few rules of thumb guiding me.

1. Don't mix asynchronous and synchronous. Pick one and stick with it.
2. Keep low level operations separate from convenience functions that can be implemented using primitives.
3. Don't mix mutable and immutable. Build a wall!

So how to construct communication protocol that can somehow express aggregation process? At the very top we have funciton called by the user but everything this function should do is to act as an entry point for the internal machinery. Therefore it makes sense to express to delegate everything from this function call into new generic function: apply-aggregation-function. This function will accept original range passed to the aggregation function as well as the object representing the function. Because I am programming in Common Lisp, it makes sense to simply add custom class for the aggregation function, and then use the instance of the function itself as it's own representation. In languages where functions are not class instances, one could simply create another instance in the function call and pass it over.

By having function representing object, we can decompose aggregation into abstract operations:

1. make-state
2. aggregate
3. state-result

Make-state function shall construct mutable state of otherwise inmutable function object. It's purpose is to hold any variables needed for the aggregation. It is worth noting that this way we will be able construct indpendent aggregation states multiple times, so GROUP BY can be completly agnostic of the concrete function it is working with. Aggregate function will accept both function representing object, state constructed by make-state and a single element from the range. State-result is called to extract the final return value of the state for the user.

Hower this is not sufficient for multipass aggregators. Here we have to additionally represent stages and therefore protocol becomes somewhat more complicated. In addition to the already listed we need additional function:

1. multi-aggregation-stages
2. initialize-stage

Function multi-aggregation-stages called on the arguments on the aggregation-function and list of arguments passed to it by the user will return list of the mutable-stages. Each stage is mutable object on it's own right, and will hold it's own state as a slot in the instance. Therefore it makes no sense to call make-state with multi-stage-aggregation-function.

Differences in handling those two function classes are strongly pronounced. We don't like that, and therefore we will combine both into one. We will introduce new level masking differences between those two approaches. It will be built around new data type called aggregator and will consist of the following protocol:

1. construct-aggregator
2. expects-content-p
3. pass-to-aggregation
4. begin-aggregation
5. end-aggregation
6. extract-result
7. aggregator-finished-p

Aggregator is mutable object that will hold both function and either stages or state. Construct-aggregator accepts function representing object and therefore it is possible to construct desired version of the aggregator based on the class of the aggregation function represeting object. Once constructed, aggregator becomes essentially a state machine, which me can modify by calls to begin-aggregation; end-aggregation; pass-to-aggregation, query by using functions expects-content-p and aggregator-finished-p. We will extract result of the aggregation by calling extract-result.
