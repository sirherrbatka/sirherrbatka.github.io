<!DOCTYPE html>
<html>
<head><meta charset="utf-8"><link rel="stylesheet" type="text/css" href="style.css"> <link href="https://fonts.googleapis.com/css?family=Inconsolata|Lato" rel="stylesheet"></head><body>
<div class="wrap"><div class="vertical-menu"><ul><li><a href="main.html#2302044199771664768">CL-DATA-STRUCTURES</a><ul><li><a href="l_1.html#199838287358526506">Overview</a><ul><li><a href="l_1.html#1334054598124453286">Conventions</a></li><li><a href="l_1.html#3345260282130244903">Key concepts</a><ul><li><a href="l_1.html#1167006943515967463">Signaling errors</a></li><li><a href="l_1.html#1020842702118139778">Modification Status</a></li><li><a href="l_1.html#1533376183908765071">Trait classes</a></li><li><a href="l_1.html#2498415301010287709">Variants</a></li></ul></li></ul></li><li><a href="l_2.html#253039147318670351">API Reference</a><ul><li><a href="l_2.html#4504423889029691808">Common API</a><ul><li><a href="l_2.html#2211029834932029248">Generic Functions</a></li><li><a href="l_2.html#1292543966797475988">Macros</a></li><li><a href="l_2.html#2197802230683919542">Classes</a></li><li><a href="l_2.html#2432534644358982004">Conditions</a></li></ul></li></ul></li><li><a href="l_3.html#3931666485041523274">Dictionary structures</a><ul><li><a href="l_3.html#2393632797174456140">API</a></li><li><a href="l_3.html#3620532292955694983">HAMT</a><ul><li><a href="l_3.html#1338230605118278950">Constructing</a></li><li><a href="l_3.html#418391189679219840">POSITION-MODIFICATION contracts</a></li></ul></li><li><a href="l_3.html#2949211009897348364">Sparse RRB Vector</a><ul><li><a href="l_3.html#3807754537950657764">Constructing</a></li></ul></li></ul></li><li><a href="l_4.html#2875044223957610475">Set structures</a><ul><li><a href="l_4.html#4253004540991457197">API</a></li><li><a href="l_4.html#306045194095426370">QP-Trie set</a></li><li><a href="l_4.html#2986122358757635751">Skip-list set</a></li></ul></li><li><a href="l_5.html#3430540343804103170">Queue structures</a><ul><li><a href="l_5.html#736676453747542885">API</a></li><li><a href="l_5.html#612639318947082217">2-3-tree</a></li></ul></li><li><a href="l_6.html#4140599406605210134">Sequence structures</a><ul><li><a href="l_6.html#2161705360457610321">API</a></li><li><a href="l_6.html#3972151251825519004">RRB vector</a></li></ul></li><li><a href="l_7.html#2156024224490829188">Algorithms Reference</a><ul><li><a href="l_7.html#1382022521975466582">Aggregation Functions</a></li><li><a href="l_7.html#3153738501303225819">Layer Functions</a></li><li><a href="l_7.html#2993032490800427822">Other Functions</a></li><li><a href="l_7.html#1277034300862545467">Variables</a></li></ul></li><li><a href="l_8.html#2499152009786510877">File System Reference</a></li><li><a href="l_9.html#4221446436371228303">Math Reference</a></li><li><a href="l_10.html#3898583616315760318">Threads Reference</a></li><li><a href="l_11.html#2800954523042733305">Streaming Algorithms Reference</a></li><li><a href="l_12.html#3910162088367688658">Internal details</a><ul><li><a href="l_12.html#2908958957756157358">Lazy evaluation</a></li><li><a href="l_12.html#2995797554166143300">POSITION-MODIFICATION metaprotocol</a><ul><li><a href="l_12.html#2624854414422749076">Generic Functions</a></li><li><a href="l_12.html#519377585175973165">Classes</a></li></ul></li><li><a href="l_12.html#379397461167302597">Aggregation algorithms metaprotocol</a></li></ul></li></ul></li></ul></div><div class="content"><div id="3898583616315760318"><h2>Threads Reference
</h2><p>This section contains reference of the multithreading utilities.</p>Symbols in the package CL-DATA-STRUCTURES.THREADS:
<div class="generic-info"><div class="doc-name">
THREAD-BUFFER
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(RANGE &amp;KEY MAXIMUM-QUEUE-SIZE CHUNK-SIZE)
</div><b>Description:</b>
Creates a proxy range that will present exactly the same content as the original range. However, when calling an aggregation function internal thread with queue will created. This allows operations performed before and after thread-buffer to run in parallel.
<br><b>Returns:</b>
Instance of BUFFER-RANGE subclass. Depending on the class of the RANGE it may be a FORWARD-BUFFER-RANGE, BIDIRECTIONAL-BUFFER-RANGE or RANDOM-ACCESS-BUFFER-RANGE.
<br><b>Exceptional situations:</b>
<ul><li>Will raise a TYPE-ERROR when MAXIMAL-QUEUE-SIZE is not integer.</li><li>Will raise a TYPE-ERROR when CHUNK-SIZE is not integer.</li><li>Will raise CL-DS:ARGUMENT-VALUE-OUT-OF-BOUNDS when CHUNK-SIZE is not at least 1.</li><li>Will raise CL-DS:ARGUMENT-VALUE-OUT-OF-BOUNDS when MAXIMAL-QUEUE-SIZE is not at least 16.</li><li>Exceptions raised during aggregation will be transfered to the original thread.</li></ul><br><b>Notes:</b>
<ul><li>Thread buffer only changes the aggregation process.</li><li>For optimal performance results, operations performed before and after THREAD-BUFFER should take approximately the same ammount of time.</li><li>Unlike PARALLEL-ON-EACH or PARALLEL-MULTIPLEX, THREAD-BUFFER does not use lparallel workers.</li><li>Because of the above, be cautious when using THREAD-BUFFER in conjuction with GROUP-BY.</li></ul><br></div><div class="generic-info"><div class="doc-name">
PARALLEL-MULTIPLEX
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(RANGE &amp;KEY KEY FUNCTION CHUNK-SIZE MAXIMUM-QUEUE-SIZE)
</div><b>Description:</b>
Like CL-DS.ALG:MULTIPLEX but when aggregation is performed, multiplexing function is applied in parallel. Obtained results are then passed with a queue into the original thread.
<br><b>Returns:</b>
Instance of PARALLEL-FORWARD-MULTIPLEX-PROXY.
<br><b>Exceptional situations:</b>
<ul><li>Will raise a TYPE-ERROR when MAXIMAL-QUEUE-SIZE is not integer.</li><li>Will raise CL-DS:ARGUMENT-VALUE-OUT-OF-BOUNDS when MAXIMAL-QUEUE-SIZE is not at least 16.</li><li>Will raise a TYPE-ERROR when FUNCTION is not funcallable.</li><li>Will raise a TYPE-ERROR when FUNCTION is not key.</li></ul><br><b>See also:</b>
<ul><li>MULTIPLEX</li></ul><br><b>Notes:</b>
<ul><li>Outside of aggregation behaves exactly like MULTIPLEX.</li></ul><br></div></div></div></div>
</body>
</html>