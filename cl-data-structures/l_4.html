<!DOCTYPE html>
<html>
<head><meta charset="utf-8"><link rel="stylesheet" type="text/css" href="style.css"> <link href="https://fonts.googleapis.com/css?family=Inconsolata|Lato" rel="stylesheet"></head><body>
<div class="wrap"><div class="vertical-menu"><ul><li><a href="main.html#3628533424809427599">CL-DATA-STRUCTURES</a><ul><li><a href="l_1.html#3910157148690515165">Overview</a><ul><li><a href="l_1.html#3455230952716915584">Conventions</a></li><li><a href="l_1.html#1078482564254963307">Key concepts</a><ul><li><a href="l_1.html#1058413383474972857">Signaling errors</a></li><li><a href="l_1.html#457998759701910961">Modification Status</a></li><li><a href="l_1.html#2189348947690640549">Trait classes</a></li><li><a href="l_1.html#1903259452612688361">Variants</a></li></ul></li></ul></li><li><a href="l_2.html#3181618838449500759">API Reference</a><ul><li><a href="l_2.html#598362327823401186">Common API</a><ul><li><a href="l_2.html#2008347494956924127">Generic Functions</a></li><li><a href="l_2.html#1658900759708926388">Macros</a></li><li><a href="l_2.html#3947312080053749104">Classes</a></li><li><a href="l_2.html#674825684962933313">Conditions</a></li></ul></li></ul></li><li><a href="l_3.html#664575659752596401">Dictionary structures</a><ul><li><a href="l_3.html#4502165871795213242">API</a></li><li><a href="l_3.html#3740607883198444714">HAMT</a><ul><li><a href="l_3.html#3589006359076266172">Constructing</a></li><li><a href="l_3.html#2999005582520038190">POSITION-MODIFICATION contracts</a></li></ul></li><li><a href="l_3.html#4478082561675546441">Sparse RRB Vector</a><ul><li><a href="l_3.html#2578899763391768306">Constructing</a></li></ul></li></ul></li><li><a href="l_4.html#3074249294444910715">Set structures</a><ul><li><a href="l_4.html#2090899491181750946">API</a></li><li><a href="l_4.html#1519458414136946816">QP-Trie set</a></li><li><a href="l_4.html#4248122472482935269">Skip-list set</a></li></ul></li><li><a href="l_5.html#2845144125356678132">Queue structures</a><ul><li><a href="l_5.html#2278324602947907792">API</a></li><li><a href="l_5.html#3356521289317317257">2-3-tree</a></li></ul></li><li><a href="l_6.html#2995423862382315203">Sequence structures</a><ul><li><a href="l_6.html#1065923900802694642">API</a></li><li><a href="l_6.html#2042377829145115153">RRB vector</a></li></ul></li><li><a href="l_7.html#3148238365653541796">Algorithms Reference</a><ul><li><a href="l_7.html#1769354496586927425">Aggregation Functions</a></li><li><a href="l_7.html#2808668683678612475">Layer Functions</a></li><li><a href="l_7.html#2402784684954070832">Other Functions</a></li></ul></li><li><a href="l_8.html#3959081551812121331">File System Reference</a></li><li><a href="l_9.html#2973809704321109611">Math Reference</a></li><li><a href="l_10.html#3026096314359506145">Clustering Reference</a></li><li><a href="l_11.html#27675359217434810">Threads Reference</a></li><li><a href="l_12.html#4504239721074351028">Streaming Algorithms Reference</a></li><li><a href="l_13.html#319119312880004768">Internal details</a><ul><li><a href="l_13.html#3118662307939772965">Lazy evaluation</a></li><li><a href="l_13.html#156752553204504888">POSITION-MODIFICATION metaprotocol</a><ul><li><a href="l_13.html#4588213663853461861">Generic Functions</a></li><li><a href="l_13.html#160895578271477435">Classes</a></li></ul></li><li><a href="l_13.html#900167745552121855">Aggregation algorithms metaprotocol</a></li></ul></li></ul></li></ul></div><div class="content"><div id="3074249294444910715"><h2>Set structures
</h2><p>Sets are collections of unique elements. Therefore the only operation which can be performed on the set is checking if objects is member of the set, removing object from the set, and adding object to the set.</p><div id="2090899491181750946"><h3>API
</h3><p>To modify content of the mutable set use the following functions.</p><ul><li>PUT!</li>
<li>ERASE!</li>
</ul><p>To query content of the set use AT function. Pass object as a key. Function will return T if element is in the set and NIL otherwise.</p></div><div id="1519458414136946816"><h3>QP-Trie set
</h3><p>QP-Trie set is dedicated storage for the (simple-array (unsigned-byte 8) (*)) objects. Primary use case are utf-8. This data structure is uniquely suited toward storing large sets of such strings because it utilizes prefix structure that will compress set to reuse memory for storing identical prefixes of the content.</p>Symbols in the package CL-DATA-STRUCTURES.SETS.QP-TRIE:
<div class="class-info"><div class="doc-name">
MUTABLE-QP-TRIE-SET
</div>
<img src="CL-DATA-STRUCTURES.SETS.QP-TRIE-MUTABLE-QP-TRIE-SET.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Mutable variant of the mutable-qp-trie-set.
<br></div><div class="function-info"><div class="doc-name">
MAKE-MUTABLE-QP-TRIE-SET
</div><div class="doc-lambda-list"><b>Lambda List:</b>
()
</div><b>Description:</b>
Constructs and returns a new instance of the mutable-qp-trie-set
<br></div></div><div id="4248122472482935269"><h3>Skip-list set
</h3><p>Skip lists are a general purpose ordered containers, like a self-balancing trees.</p>Symbols in the package CL-DATA-STRUCTURES.SETS.SKIP-LIST:
<div class="class-info"><div class="doc-name">
MUTABLE-SKIP-LIST-SET
</div>
<img src="CL-DATA-STRUCTURES.SETS.SKIP-LIST-MUTABLE-SKIP-LIST-SET.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Mutable skip list set.
<br></div><div class="function-info"><div class="doc-name">
MAKE-MUTABLE-SKIP-LIST-SET
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(ORDERING TEST &amp;KEY (MAXIMUM-LEVEL 32))
</div><b>Description:</b>
Constructs and returns a new instance of mutable-skip-list.
<br></div></div></div></div></div>
</body>
</html>