<!DOCTYPE html>
<html>
<head><meta charset="utf-8"><link rel="stylesheet" type="text/css" href="style.css"> <link href="https://fonts.googleapis.com/css?family=Inconsolata|Lato" rel="stylesheet"></head><body>
<div class="wrap"><div class="vertical-menu"><ul><li><a href="main.html#93454784038703750">CL-DATA-STRUCTURES</a><ul><li><a href="l_1.html#2915347479523595354">Overview</a><ul><li><a href="l_1.html#1402128066910974000">Conventions</a></li><li><a href="l_1.html#4422181156229413200">Key concepts</a><ul><li><a href="l_1.html#3457899492373935379">Signaling errors</a></li><li><a href="l_1.html#4494850749888703431">Modification Status</a></li><li><a href="l_1.html#1078237372641619125">Trait classes</a></li><li><a href="l_1.html#2616954079821506425">Variants</a></li></ul></li></ul></li><li><a href="l_2.html#1731368207376988377">API Reference</a><ul><li><a href="l_2.html#1548608948879691400">Common API</a><ul><li><a href="l_2.html#1675540849095794200">Generic Functions</a></li><li><a href="l_2.html#635673200336401825">Macros</a></li><li><a href="l_2.html#3838660289970480331">Classes</a></li><li><a href="l_2.html#3624740441342519531">Conditions</a></li></ul></li></ul></li><li><a href="l_3.html#1136681497732396850">Algorithms Reference</a><ul><li><a href="l_3.html#2215445351760617277">Aggregation Functions</a></li><li><a href="l_3.html#3740146220209712300">Layer Functions</a></li><li><a href="l_3.html#3556917838540363700">Other Functions</a></li></ul></li><li><a href="l_4.html#3546773778612793300">File System Reference</a></li><li><a href="l_5.html#3762499706087560754">Math Reference</a></li><li><a href="l_6.html#195384756183537050">Clustering Reference</a></li><li><a href="l_7.html#1526664839957526100">Threads Reference</a></li><li><a href="l_8.html#4535723406767194531">Dictionary structures</a><ul><li><a href="l_8.html#2325181301345407054">API</a></li><li><a href="l_8.html#3700923029416658831">HAMT</a><ul><li><a href="l_8.html#4003199250282897931">Constructing</a></li><li><a href="l_8.html#363488831412731050">POSITION-MODIFICATION contracts</a></li></ul></li><li><a href="l_8.html#3263226158868937625">Sparse RRB Vector</a></li></ul></li><li><a href="l_9.html#665556909573677550">Internal details</a><ul><li><a href="l_9.html#4534292306482965331">Lazy evaluation</a></li><li><a href="l_9.html#384726165884717475">POSITION-MODIFICATION metaprotocol</a><ul><li><a href="l_9.html#1133046826893938775">Generic Functions</a></li><li><a href="l_9.html#1157172328232937577">Classes</a></li></ul></li><li><a href="l_9.html#1314824774483757227">Aggregation algorithms metaprotocol</a></li></ul></li></ul></li></ul></div><div class="content"><div id="4535723406767194531"><h2>Dictionary structures
</h2><p>Dictionaries map values to unique keys.Common Lispstandard already contains such structures (hash tables, alists, plists) and therefore idea should not be alien to a Lisp programmer. CL-DATA-STRUCTURES offers both functional and mutable dictionaries, with HAMT being the prime example of complete, feature rich implementation of the protocol. In practice, containers present in this module are either ordered containers (for instance binary search trees) or some sort of unordered hash table (either classiscal hashtable or some sort of hashing tree). In each case, overview of data structure is present in this document.</p><div id="2325181301345407054"><h3>API
</h3><p>To obtain value under key use following functions:</p><ul><li>AT</li>
</ul><p>To change mapping use following purely functional functions:</p><ul><li>INSERT</li>
<li>ADD</li>
<li>UPDATE</li>
<li>UPDATE-IF</li>
<li>ERASE</li>
<li>ERASE-IF</li>
</ul><p>To change mapping in destructive way, use following functions:</p><ul><li>(SETF AT)</li>
<li>ADD!</li>
<li>UPDATE!</li>
<li>UPDATE-IF!</li>
<li>ERASE!</li>
<li>ERASE-IF!</li>
</ul><p>This package adds another set of trait classes, specific to dictionaries.</p><div class="class-info"><div class="doc-name">
FUNDAMENTAL-DICTIONARY
</div>
<img src="CL-DATA-STRUCTURES.DICTS-FUNDAMENTAL-DICTIONARY.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Container that provides location to value mapping. Either ordered or unordered.
<br></div><div class="class-info"><div class="doc-name">
FUNDAMENTAL-HASHING-DICTIONARY
</div>
<img src="CL-DATA-STRUCTURES.DICTS-FUNDAMENTAL-HASHING-DICTIONARY.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Dictionary that uses hashing function. Hashing function is assumed to return fixnum.
<br></div><div class="class-info"><div class="doc-name">
FUNCTIONAL-DICTIONARY
</div>
<img src="CL-DATA-STRUCTURES.DICTS-FUNCTIONAL-DICTIONARY.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Functional variant of a dictionary.
<br></div><div class="class-info"><div class="doc-name">
MUTABLE-DICTIONARY
</div>
<img src="CL-DATA-STRUCTURES.DICTS-MUTABLE-DICTIONARY.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Mutable variant of a dictionary.
<br></div><div class="class-info"><div class="doc-name">
TRANSACTIONAL-DICTIONARY
</div>
<img src="CL-DATA-STRUCTURES.DICTS-TRANSACTIONAL-DICTIONARY.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Transactional variant of a dictionary.
<br></div><div class="class-info"><div class="doc-name">
LAZY-DICTIONARY
</div>
<img src="CL-DATA-STRUCTURES.DICTS-LAZY-DICTIONARY.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Lazy variant of a dictionary.
<br></div><div class="class-info"><div class="doc-name">
FUNCTIONAL-HASHING-DICTIONARY
</div>
<img src="CL-DATA-STRUCTURES.DICTS-FUNCTIONAL-HASHING-DICTIONARY.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Functional variant of hashing a dictionary.
<br></div><div class="class-info"><div class="doc-name">
MUTABLE-HASHING-DICTIONARY
</div>
<img src="CL-DATA-STRUCTURES.DICTS-MUTABLE-HASHING-DICTIONARY.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Mutable variant of hashing a dictionary.
<br></div><div class="class-info"><div class="doc-name">
TRANSACTIONAL-HASHING-DICTIONARY
</div>
<img src="CL-DATA-STRUCTURES.DICTS-TRANSACTIONAL-HASHING-DICTIONARY.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Transactional variant of hashing a dictionary.
<br></div><div class="class-info"><div class="doc-name">
LAZY-HASHING-DICTIONARY
</div>
<img src="CL-DATA-STRUCTURES.DICTS-LAZY-HASHING-DICTIONARY.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Lazy variant of a hashing dictionary.
<br></div><p>In addition to this, on this level, few additional functions are defined.</p><div class="generic-info"><div class="doc-name">
FIND-CONTENT
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(CONTAINER BUCKET LOCATION &amp;KEY HASH &amp;ALLOW-OTHER-KEYS)
</div><b>Arguments:</b>
<ul><li>CONTAINER, Container that owns bucket. Acts as passed interface for method dispatch.</li><li>BUCKET, Bucket that will be searched.</li><li>LOCATION, Location that will be searched.</li></ul><br><b>Description:</b>
Attempts to find element under LOCATION in the the bucket.
<br><b>Returns:</b>
<ul><li>Element</li><li>Boolean. T if element was found, NIL otherwise.</li></ul><br><b>Notes:</b>
This function accepts additional key arguments. In case of hashing dictionaries, one will be :hash that is expected to be a fixnum.
<br></div></div><div id="3700923029416658831"><h3>HAMT
</h3><p>HAMT stands from hash array mapped trie. This data structure is used the most commonly as functional dictionary in standard libraries of few recent languages (including Clojure and Scala). Cl-data-structures implementation offers also mutable and transactional variant of this structure. Although this container is not optimized for destructive modification, it is still faster then copy-on-write whole path from root to the bottom (conflict) node.</p><p>Dictionary implementation of HAMT is present in the system as a class.</p><div class="class-info"><div class="doc-name">
HAMT-DICTIONARY
</div>
<img src="CL-DATA-STRUCTURES.DICTS.HAMT-HAMT-DICTIONARY.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Root HAMT dictionary class.
<br></div><div class="class-info"><div class="doc-name">
FUNCTIONAL-HAMT-DICTIONARY
</div>
<img src="CL-DATA-STRUCTURES.DICTS.HAMT-FUNCTIONAL-HAMT-DICTIONARY.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
HAMT dictionary that implements functional api.
<br></div><div class="class-info"><div class="doc-name">
MUTABLE-HAMT-DICTIONARY
</div>
<img src="CL-DATA-STRUCTURES.DICTS.HAMT-MUTABLE-HAMT-DICTIONARY.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
HAMT dictionary that implements mutable api.
<br></div><p>As you can see, it inherits DICTIONARY trait class as well as lower level FUNDAMENTAL-HAMT-CONTAINER class. All instances of this class can be used with following functions:</p><div class="function-info"><div class="doc-name">
HAMT-DICTIONARY-AT
</div><div class="doc-lambda-list"><b>Lambda List:</b>
()
</div><div class="doc-paragraph">Implementation of AT</div></div><div class="function-info"><div class="doc-name">
HAMT-DICTIONARY-SIZE
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(CONTAINER)
</div><div class="doc-paragraph">Implementation of SIZE</div></div><p>Functional dictionary is represented by the following class:</p><p>There is no lazy-hamt-dictionary class, because lazy hamt dictionary is nothing more then a TRANSACTIONAL-HAMT-DICTIONARY inside LAZY-BOX.</p><div id="4003199250282897931"><h4>Constructing
</h4><p>To construct HAMT dictionary, use following functions.</p>Symbols in the package CL-DATA-STRUCTURES.DICTS.HAMT:
<div class="function-info"><div class="doc-name">
MAKE-FUNCTIONAL-HAMT-DICTIONARY
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(HASH-FN EQUAL-FN)
</div><b>Syntax:</b>
make-functional-hamt-dictionary hash-fn equal-fn &amp;key max-depth =&gt; functional-hamt-dictionary
<br><b>Description:</b>
Constructs and return new functional-hamt-dictionary
<br><b>Returns:</b>
new instance of functional-hamt-dictionary.
<br><b>Notes:</b>
In theory HAMT can use infinite length of hash but this implementation uses 60 oldest bits at most.
<br></div><div class="function-info"><div class="doc-name">
MAKE-MUTABLE-HAMT-DICTIONARY
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(HASH-FN EQUAL-FN)
</div><b>Syntax:</b>
make-mutable-hamt-dictionary hash-fn equal-fn &amp;key max-depth =&gt; mutable-hamt-dictionary
<br><b>Description:</b>
Constructs and returns a new mutable-hamt-dictionary
<br><b>Returns:</b>
new instance of mutable-hamt-dictionary.
<br><b>Notes:</b>
In theory HAMT can use infinite length of hash but this implementation uses 60 oldest bits at most.
<br></div></div><div id="363488831412731050"><h4>POSITION-MODIFICATION contracts
</h4><p>Since HAMT is hashing container, many of the functions accept additional hash key argument with fixnum produced by the hashing function.</p><p>SHRINK-BUCKET function must be defined in terms all functional shrink-functions and buckets. Will accept :hash.</p><p>GROW-BUCKET function must be defined in terms all functional grow-functions and buckets. Will accept :hash.</p><p>SHRINK-BUCKET! function must be defined in terms all mutable shrink-functions and buckets. Will accept :hash.</p><p>GROW-BUCKET! function must be defined in terms all mutable grow-functions and buckets. Will accept :hash.</p><p>MAKE-BUCKET function must be defined in terms of all grow-functions and will return list of hash-content-tuple as bucket. Will accept :hash</p><p>Bucket must be usable with cl-ds.dicts:find-content. FIND-CONTENT function will accept hash as key argument.</p></div></div><div id="3263226158868937625"><h3>Sparse RRB Vector
</h3><p>Sparse variant of the RRB vector. Unlike the cl:hash-table, this container will guarantee that the content is stored in the ascending order.</p></div></div></div></div>
</body>
</html>