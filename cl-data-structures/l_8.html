<!DOCTYPE html>
<html>
<head><meta charset="utf-8"><link rel="stylesheet" type="text/css" href="style.css"> <link href="https://fonts.googleapis.com/css?family=Inconsolata|Lato" rel="stylesheet"></head><body>
<div class="wrap"><div class="vertical-menu"><ul><li><a href="main.html#4505409305299236754">CL-DATA-STRUCTURES</a><ul><li><a href="l_1.html#1735195540784848027">Overview</a><ul><li><a href="l_1.html#1535638354865863627">Conventions</a></li><li><a href="l_1.html#1322525669106268250">Key concepts</a><ul><li><a href="l_1.html#1754091002460578277">Signaling errors</a></li><li><a href="l_1.html#2124346434595374927">Modification Status</a></li><li><a href="l_1.html#95769426742277925">Trait classes</a></li><li><a href="l_1.html#325416538310996600">Variants</a></li></ul></li></ul></li><li><a href="l_2.html#4571650879098654977">API Reference</a><ul><li><a href="l_2.html#2034164880569481400">Common API</a><ul><li><a href="l_2.html#156661800231914575">Generic Functions</a></li><li><a href="l_2.html#754045841682703050">Macros</a></li><li><a href="l_2.html#3177484327573439654">Classes</a></li><li><a href="l_2.html#1184141857060006650">Conditions</a></li></ul></li></ul></li><li><a href="l_3.html#2743197245523832179">Algorithms Reference</a><ul><li><a href="l_3.html#2911948354355545700">Aggregation Functions</a></li><li><a href="l_3.html#2922380124478866679">Layer Functions</a></li><li><a href="l_3.html#4476501792737127077">Other Functions</a></li></ul></li><li><a href="l_4.html#3547825047021396054">File System Reference</a></li><li><a href="l_5.html#3551831363527806777">Math Reference</a></li><li><a href="l_6.html#1298919889949082377">Clustering Reference</a></li><li><a href="l_7.html#2507098244814471754">Threads Reference</a></li><li><a href="l_8.html#3472896445517452200">Streaming Algorithms Reference</a></li><li><a href="l_9.html#1427587724679790050">Dictionary structures</a><ul><li><a href="l_9.html#1308599760548287027">API</a></li><li><a href="l_9.html#64087778694970875">HAMT</a><ul><li><a href="l_9.html#1749384798484054227">Constructing</a></li><li><a href="l_9.html#427756177321805800">POSITION-MODIFICATION contracts</a></li></ul></li><li><a href="l_9.html#886153111997054525">Sparse RRB Vector</a></li></ul></li><li><a href="l_10.html#3400828039905979479">Internal details</a><ul><li><a href="l_10.html#746729226374457625">Lazy evaluation</a></li><li><a href="l_10.html#1980610612256975727">POSITION-MODIFICATION metaprotocol</a><ul><li><a href="l_10.html#3537932964235382054">Generic Functions</a></li><li><a href="l_10.html#4599118105515222577">Classes</a></li></ul></li><li><a href="l_10.html#2020431700079153077">Aggregation algorithms metaprotocol</a></li></ul></li></ul></li></ul></div><div class="content"><div id="3472896445517452200"><h2>Streaming Algorithms Reference
</h2><p>This section contains reference of the data sketches.</p>Symbols in the package CL-DATA-STRUCTURES.STREAMING-ALGORITHMS:
<div class="generic-info"><div class="doc-name">
BLOOM-FILTER
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(RANGE &amp;KEY HASH-FN SPACE COUNT KEY HASHES DATA-SKETCH)
</div><b>Arguments:</b>
<ul><li>RANGE, Input for the creation of the bloom filter.</li><li>SPACE, Positive-fixnum. What is the bloom vector size?</li><li>COUNT, How many bits are used for each item?</li><li>KEY, Function used to extract value for to hashing.</li><li>HASHES, Optional hashes vector. Needs to be supplied in order to ensure that the same hash values are generated between different filters.</li><li>DATA-SKETCH, Instead of the bits and the hash-fn, the user can pass a data-sketch argument.</li></ul><br><b>Description:</b>
Creates bloom filter out of elements in the range. Bloom filter is memory efficient data structures allowing to check if an item is absent from the range (if AT returns nil, the item is certainly absent, if at returns T item either present or not).
<br><b>Returns:</b>
Instance of the fundamental-data-sketch class. Use cl-ds:at to check if element is present. False positives are possible, false negatives are not possible.
<br></div><div class="generic-info"><div class="doc-name">
APPROXIMATED-COUNTS
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(RANGE &amp;KEY HASH-FN SPACE COUNT KEY HASHES DATA-SKETCH)
</div><b>Arguments:</b>
<ul><li>RANGE, Object to aggregate.</li><li>HASH-FN, Hashing function. SXHASH will do for strings.</li><li>SPACE, Positive integer. Size of the counters array</li><li>COUNT, Number of hashing functions used.</li><li>DATA-SKETCH, Instead of the bits and the hash-fn, the user can pass a data-sketch argument.</li></ul><br><b>Description:</b>
Calculates estimated counts using Min-Count sketch algorithm. This requires only a constant amount of memory.
<br><b>Returns:</b>
Instance of the fundamental-data-sketch class. Use CL-DS:AT to extract count estimate for element from it.
<br><b>Notes:</b>
<ul><li>Quality of the estimate directly depends on DEPTH and WIDTH.</li><li>Sensitive to a hash function. Large avalanche factor is very helpful.</li></ul><br></div><div class="generic-info"><div class="doc-name">
APPROXIMATED-SET-CARDINALITY
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(RANGE &amp;KEY BITS HASH-FN KEY DATA-SKETCH)
</div><b>Arguments:</b>
<ul><li>RANGE, Object to aggregate.</li><li>BITS, How many bits per register should be used? Should be at least 4, and 20 at most. Large values are beneficial for high accuracy of the result but will require more memory.</li><li>HASH-FN, Hashing function. SXHASH will do for strings.</li><li>DATA-SKETCH, Instead of the bits and the hash-fn, the user can pass a data-sketch argument.</li><li>KEY, A function used to extract value from each element.</li></ul><br><b>Examples:</b>
<pre><code>(LET ((DATA
       (CL-DATA-STRUCTURES:XPR (:I 0)
         (WHEN (&lt; I 500000)
           (CL-DATA-STRUCTURES:SEND-RECUR (RANDOM 99999999999) :I (1+ I))))))
  (PROVE.TEST:OK
   (&lt; 490000
      (CL-DATA-STRUCTURES:VALUE
       (CL-DATA-STRUCTURES.STREAMING-ALGORITHMS:APPROXIMATED-SET-CARDINALITY
        DATA :BITS 20 :HASH-FN #&#039;SXHASH))
      510000)))</pre></code><br><b>Description:</b>
Calculates the estimated set cardinality using the HyperLogLog algorithm. This requires only a constant (and modest) amount of memory.
<br><b>Returns:</b>
Instance of the fundamental-data-sketch class. Use CL-DS:VALUE to extract estimate from it.
<br><b>Notes:</b>
<ul><li>This algorithm gives a solid estimate for large sets, not so good for small sets.</li><li>Fairly sensitive to a hash function. Large avalanche factor is very helpful.</li><li>Can be used to (for instance) estimate number of keys before creating a hash table. A good estimate of size minimizes rehashing and therefore reduces both memory allocation and time required to fill the hash table.</li></ul><br></div><div class="generic-info"><div class="doc-name">
UNION
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(FIRST-SKETCH &amp;REST MORE-SKETCHES)
</div><b>Description:</b>
Creates new data-sketch from the provided. Can be used to join sketches build on different data chunks.
<br></div><div class="generic-info"><div class="doc-name">
CLEAN-SKETCH
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(FUNCTION &amp;REST ARGUMENTS &amp;KEY HASHES HASH-FN SPACE COUNT BITS)
</div><b>Description:</b>
Creates a new, empty data-sketch that would be produced by the function. New data-sketch can be cloned and passed as :data-sketch. This allows to keep compatibility between results of call to the streaming function.
<br></div><div class="class-info"><div class="doc-name">
FUNDAMENTAL-DATA-SKETCH
</div>
<img src="CL-DATA-STRUCTURES.STREAMING-ALGORITHMS-FUNDAMENTAL-DATA-SKETCH.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
The base class of all data sketches. Instances of this class can be passed to streaming algorihms as initial states, cloned and combined into unions.
<br></div></div></div></div>
</body>
</html>