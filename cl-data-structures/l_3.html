<!DOCTYPE html>
<html>
<head><meta charset="utf-8"><link rel="stylesheet" type="text/css" href="style.css"> <link href="https://fonts.googleapis.com/css?family=Inconsolata|Lato" rel="stylesheet"></head><body>
<div class="wrap"><div class="vertical-menu"><ul><li><a href="main.html#1541111885889045600">CL-DATA-STRUCTURES</a><ul><li><a href="l_1.html#3943893143508621231">Overview</a><ul><li><a href="l_1.html#2820254041979631725">Conventions</a></li><li><a href="l_1.html#427509358435976700">Key concepts</a><ul><li><a href="l_1.html#856528140179865400">Signaling errors</a></li><li><a href="l_1.html#1917385616256905277">Modification Status</a></li><li><a href="l_1.html#503502265721762450">Trait classes</a></li><li><a href="l_1.html#2805561422702800125">Variants</a></li></ul></li></ul></li><li><a href="l_2.html#761871452491929650">API Reference</a><ul><li><a href="l_2.html#1293295163192038500">Common API</a><ul><li><a href="l_2.html#868889441542580575">Generic Functions</a></li><li><a href="l_2.html#2555001373394780379">Macros</a></li><li><a href="l_2.html#3047732226200363325">Classes</a></li><li><a href="l_2.html#2316198597354531179">Conditions</a></li></ul></li></ul></li><li><a href="l_3.html#3992417262083484000">Internal details</a><ul><li><a href="l_3.html#3336565136066834754">Docstrings and docstample</a></li><li><a href="l_3.html#943098342892256200">POSITION-MODIFICATION metaprotocol</a><ul><li><a href="l_3.html#3210272581461784479">Generic Functions</a></li><li><a href="l_3.html#1998846525869216077">Classes</a></li></ul></li><li><a href="l_3.html#2170013682656198600">Lazy evaluation</a></li></ul></li><li><a href="l_4.html#3297432896575067900">Dictionary structures</a><ul><li><a href="l_4.html#3252014999283296679">API</a></li><li><a href="l_4.html#4542141672756328231">HAMT</a><ul><li><a href="l_4.html#341833260541263400">Constructing</a></li><li><a href="l_4.html#1143893301879878550">POSITION-MODIFICATION contracts</a></li></ul></li></ul></li></ul></li></ul></div><div class="content"><div id="3992417262083484000"><h2>Internal details
</h2><p>This section explains parts of system design and low-level elements that shouldn&#039;t bother user of the library.  However, they are critical for contributors, and some people just want to know and so shall be delivered.</p><div id="3336565136066834754"><h3>Docstrings and docstample
</h3><p>Majority of docstrings are constructed and set outside function definitions, in a separate file. This has been done in such way to not clutter the code with information that is easy to obtain by any SLIME user. Furthermore this allows to build doctsrings with the code itself. This makes easier to ensure common, uniform style of docstrings. It may also perform various operations on docstrings. To handle this, a separate project called docstample was created. Hopefully, this tool can be augmented in the future to handle tasks such as automatic validation of examples. This is in fact what is done in this project. Examples are written as unit tests, so they can be checked if they actually work (so users are not getting angry, hopefully). Also, building docstrings from structured input eliminates need for parsing (a language other than lisp itself) to build a nicely formatted output (which is nice).</p></div><div id="943098342892256200"><h3>POSITION-MODIFICATION metaprotocol
</h3><p>The package defines its own internal object protocol that is used to build parts of user API responsible for container modifications. This concept is nicknamed position-modification metaprotocol and is described in this section.</p><p>As every object protocol, position-modification metaprotocol consists of classes and generic functions that are expected to be implemented for said classes. Those functions are designed to peform low level (that is: dependent on the internals structure) operations on containers. For instance, those operations include manipulations (and construction) of buckets (and &quot;bucket&quot; is obviously low level term used in description of data structure).</p><p>Layer as a whole, derive it&#039;s name from one particular generic function called POSITION-MODIFICATION. It acts as a point of implementation for all functionality releated to modification of containers and therefore is called directly by functions like INSERT. Methods implementing POSITION-MODIFICATION act by calling other functions of this protocol.</p><img src="1.svg" class="centered">
<p>POSITION-MODIFICATION accepts OPERATION as a first argument. OPERATION is object of one of protocol classes FUNCTIONAL-FUNCTION or DESTRUCTIVE-FUNCTION. Objects of those classes include generic functions defined as part of the API. This is made possible by the fact that Generic Functions in Common Lisp are in fact objects of their own classes. In addition to those fundamental classes, protocol contains additional trait classes like for instance the GROW-FUNCTION. Because of this, it is possible to query API functions for expected behavior. It also makes possible to write methods that dispatch on behavior of the API functions. These include (as already established) bucket manipulation functions: SHRINK-BUCKET, GROW-BUCKET, MAKE-BUCKET.</p><p>Because all of those functions are generic ; and just like POSITION-MODIFICATION they accept OPERATION argument, it is possible to dispatch bucket modification logic, based on the class of the API function. Employing this approach allows to remove code duplication between various types of modification functions, and therefore reduce the burden of supporting functions like ERASE-IF in the codebase. Furthermore, establishing this protocol allows to alter standard behavior of buckets, and by that, create nested data structures.</p><p>Nested data structures are nontrivial problem when immutable behavior is expected. In most cases immutability is achieved by using copy-on-write semenatic. Because copying in nested structures has to happen on multiple levels, It is essential to be able to intercept logic at the lower level of data structure. Luckly, as described, Common Lisp offers tools that allowed us to build elegant solution for such problem.</p><div id="3210272581461784479"><h4>Generic Functions
</h4>Symbols in package CL-DATA-STRUCTURES:
<div class="generic-info"><div class="doc-name">
POSITION-MODIFICATION
</div><div class="doc-lambda-list"><b>Arguments:</b>
(OPERATION CONTAINER LOCATION &amp;REST ALL &amp;KEY VALUE &amp;ALLOW-OTHER-KEYS)
</div><div class="doc-paragraph">
<b>Description:</b>
Low level function used as de facto implementation point of all API modification functions (INSERT, ADD, UPDATE).</div>
<b>Returns:</b>
<div class="doc-paragraph">
<ol><li>Container (new or the same instance)</li>
<li>Modification status</li>
</ol></div>
<b>Notes:</b>
<div class="doc-paragraph">
Implementations of this generic function are multimethods dispatched by the class of the OPERATION and CONTAINER.</div>
</div><div class="generic-info"><div class="doc-name">
MAKE-BUCKET
</div><div class="doc-lambda-list"><b>Arguments:</b>
(OPERATION CONTAINER LOCATION &amp;REST ALL &amp;KEY HASH VALUE &amp;ALLOW-OTHER-KEYS)
</div><div class="doc-paragraph">
<b>Description:</b>
Generic, low level function used to create all sorts of buckets (like those in dictionaries). Buckets are modified by grow-bucket and shrink-bucket functions.</div>
<b>Returns:</b>
<div class="doc-paragraph">
New bucket. Precise type of bucket is not relevant to this level of abstraction and usually is defined in context of specific container.</div>
<b>Notes:</b>
<div class="doc-paragraph">
This function is not allowed to perform any side effects.</div>
</div><div class="generic-info"><div class="doc-name">
GROW-BUCKET
</div><div class="doc-lambda-list"><b>Arguments:</b>
(OPERATION CONTAINER BUCKET LOCATION &amp;REST ALL &amp;KEY HASH VALUE
 &amp;ALLOW-OTHER-KEYS)
</div><div class="doc-paragraph">
<b>Description:</b>
Generic, low level function used to grow all sorts of buckets (like those in dictionaries). Buckets are created by make-bucket function.</div>
<b>Returns:</b>
<div class="doc-paragraph">
<ol><li>Bucket.</li>
<li>Instance of modification-operation-status.</li>
<li>Boolean. T if element was added into container, NIL otherwise. If NIL was returned, POSITION-MODIFICATION may assume that container was not changed, and therefore ignore returned bucket.</li>
</ol></div>
<b>Notes:</b>
<div class="doc-paragraph">
This function is not allowed to perform any side effects. See grow-bucket! for function that is allowed to do so.</div>
</div><div class="generic-info"><div class="doc-name">
SHRINK-BUCKET
</div><div class="doc-lambda-list"><b>Arguments:</b>
(OPERATION CONTAINER BUCKET LOCATION &amp;REST ALL &amp;KEY HASH CONDITION-FN
 &amp;ALLOW-OTHER-KEYS)
</div><div class="doc-paragraph">
<b>Description:</b>
Generic, low level function used to shrink all sorts of buckets (like those in dictionaries). Buckets are created by make-bucket function.</div>
<b>Returns:</b>
<div class="doc-paragraph">
<ol><li>Bucket. May also return nil to indicate empty bucket.</li>
<li>Instance of modification-operation-status.</li>
<li>Boolean. T if element was removed from container, NIL otherwise. If NIL was returned, POSITION-MODIFICATION may assume that container was not changed, and therefore ignore returned bucket.</li>
</ol></div>
<b>Notes:</b>
<div class="doc-paragraph">
This function is not allowed to perform any side effects. See shrink-bucket! for function that is allowed to do so.</div>
</div><div class="generic-info"><div class="doc-name">
GROW-BUCKET!
</div><div class="doc-lambda-list"><b>Arguments:</b>
(OPERATION CONTAINER BUCKET LOCATION &amp;REST ALL &amp;KEY HASH VALUE
 &amp;ALLOW-OTHER-KEYS)
</div><div class="doc-paragraph">
<b>Description:</b>
Generic, low level function used to destructivly grow all sorts of buckets (like those in dictionaries). Buckets are created by make-bucket function.</div>
<b>Returns:</b>
<div class="doc-paragraph">
<ol><li>New or passed bucket.</li>
<li>Instance of position modification status.</li>
<li>Boolean. T if returned bucket contains new elements, NIL otherwise. If NIL was returned, position-modification is free to ignore first value.</li>
</ol></div>
<div class="doc-paragraph">
<b>Side Effects:</b>
Can modify bucket.</div>
</div><div class="generic-info"><div class="doc-name">
SHRINK-BUCKET!
</div><div class="doc-lambda-list"><b>Arguments:</b>
(OPERATION CONTAINER BUCKET LOCATION &amp;REST ALL &amp;KEY HASH CONDITION-FN
 &amp;ALLOW-OTHER-KEYS)
</div><div class="doc-paragraph">
<b>Description:</b>
Generic, low level function used to destructivly shrink all sorts of buckets (like those in dictionaries). Buckets are created by make-bucket function.</div>
<b>Returns:</b>
<div class="doc-paragraph">
<ol><li>New or passed bucket. May return nil as empty bucket.</li>
<li>Instance of position modification status.</li>
<li>Boolean. T if elements were removed from BUCKET, NIL otherwise. If NIL was returned, position-modification is free to ignore first value.</li>
</ol></div>
<div class="doc-paragraph">
<b>Side Effects:</b>
Can modify bucket.</div>
</div><div class="generic-info"><div class="doc-name">
FUNCTIONAL-COUNTERPART
</div><div class="doc-lambda-list"><b>Arguments:</b>
(OPERATION)
</div><div class="doc-paragraph">
<b>Description:</b>
Low level function that returns an instance of the functional api modification function that serves the same purpose as the OPERATION. Will, for instance, return #&#039;UPDATE when OPERATION is #&#039;UPDATE! Will return original the OPERATION if OPERATION is already part of the functional API.</div>
<b>Returns:</b>
<div class="doc-paragraph">
The instance of api function.</div>
<b>Notes:</b>
<div class="doc-paragraph">
This function is low level, and therefore should be rarely (if ever) used by the user of this library.</div>
</div><div class="generic-info"><div class="doc-name">
DESTRUCTIVE-COUNTERPART
</div><div class="doc-lambda-list"><b>Arguments:</b>
(OPERATION)
</div><div class="doc-paragraph">
<b>Description:</b>
Low level function that returns an instance of the destrutive api modification function that serves the same purpose as the OPERATION. Will, for instance, return #&#039;UPDATE! when OPERATION is #&#039;UPDATE Will return original the OPERATION if OPERATION is already part of the functional API.</div>
<b>Returns:</b>
<div class="doc-paragraph">
The instance of api function.</div>
<b>Notes:</b>
<div class="doc-paragraph">
This function is low level, and therefore should be rarely (if ever) used by the user of this library.</div>
</div></div><div id="1998846525869216077"><h4>Classes
</h4>Symbols in package CL-DATA-STRUCTURES:
<div class="class-info"><div class="doc-name">
FUNCTIONAL-FUNCTION
</div>
<img src="CL-DATA-STRUCTURES-FUNCTIONAL-FUNCTION.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Function that inherits this class is not allowed to perform any side effects.</div><div class="class-info"><div class="doc-name">
DESTRUCTIVE-FUNCTION
</div>
<img src="CL-DATA-STRUCTURES-DESTRUCTIVE-FUNCTION.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Function that inherits this class is expected to perform side effects.</div><div class="class-info"><div class="doc-name">
SHRINK-FUNCTION
</div>
<img src="CL-DATA-STRUCTURES-SHRINK-FUNCTION.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Function will attempt to remove element from container.</div><div class="class-info"><div class="doc-name">
GROW-FUNCTION
</div>
<img src="CL-DATA-STRUCTURES-GROW-FUNCTION.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Function will attempt to add new element to container.</div><div class="class-info"><div class="doc-name">
INSERT-FUNCTION
</div>
<img src="CL-DATA-STRUCTURES-INSERT-FUNCTION.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Class of INSERT and (SETF AT).</div><div class="class-info"><div class="doc-name">
UPDATE-FUNCTION
</div>
<img src="CL-DATA-STRUCTURES-UPDATE-FUNCTION.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Class of UPDATE and UPDATE!.</div><div class="class-info"><div class="doc-name">
ADD-FUNCTION
</div>
<img src="CL-DATA-STRUCTURES-ADD-FUNCTION.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Class of ADD and ADD!.</div><div class="class-info"><div class="doc-name">
ERASE-FUNCTION
</div>
<img src="CL-DATA-STRUCTURES-ERASE-FUNCTION.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Class of ERASE and ERASE!.</div><div class="class-info"><div class="doc-name">
ERASE-IF-FUNCTION
</div>
<img src="CL-DATA-STRUCTURES-ERASE-IF-FUNCTION.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Class of ERASE-IF.</div><div class="class-info"><div class="doc-name">
FUNCTIONAL-INSERT-FUNCTION
</div>
<img src="CL-DATA-STRUCTURES-FUNCTIONAL-INSERT-FUNCTION.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Class of INSERT.</div><div class="class-info"><div class="doc-name">
FUNCTIONAL-UPDATE-FUNCTION
</div>
<img src="CL-DATA-STRUCTURES-FUNCTIONAL-UPDATE-FUNCTION.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Class of UPDATE.</div><div class="class-info"><div class="doc-name">
FUNCTIONAL-ADD-FUNCTION
</div>
<img src="CL-DATA-STRUCTURES-FUNCTIONAL-ADD-FUNCTION.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Class of ADD.</div><div class="class-info"><div class="doc-name">
FUNCTIONAL-ERASE-FUNCTION
</div>
<img src="CL-DATA-STRUCTURES-FUNCTIONAL-ERASE-FUNCTION.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Class of ERASE.</div><div class="class-info"><div class="doc-name">
FUNCTIONAL-ERASE-IF-FUNCTION
</div>
<img src="CL-DATA-STRUCTURES-FUNCTIONAL-ERASE-IF-FUNCTION.svg" alt="Inheritance" class="centered">
<br>
</div><div class="class-info"><div class="doc-name">
INSERT!-FUNCTION
</div>
<img src="CL-DATA-STRUCTURES-INSERT!-FUNCTION.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Class of INSERT.</div><div class="class-info"><div class="doc-name">
UPDATE!-FUNCTION
</div>
<img src="CL-DATA-STRUCTURES-UPDATE!-FUNCTION.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Class of UPDATE.</div><div class="class-info"><div class="doc-name">
ADD!-FUNCTION
</div>
<img src="CL-DATA-STRUCTURES-ADD!-FUNCTION.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Class of ADD.</div><div class="class-info"><div class="doc-name">
ERASE!-FUNCTION
</div>
<img src="CL-DATA-STRUCTURES-ERASE!-FUNCTION.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Class of ERASE.</div><div class="class-info"><div class="doc-name">
ERASE-IF!-FUNCTION
</div>
<img src="CL-DATA-STRUCTURES-ERASE-IF!-FUNCTION.svg" alt="Inheritance" class="centered">
<br>
<b>Description:</b>
Class of ERASE-IF!.</div></div></div><div id="2170013682656198600"><h3>Lazy evaluation
</h3><p>This system offers the lazy-evaluated containers. Lazy evaluation is useful primarly because eager functional data structures may have somewhat sluggish performance if multiple, full copy-on-write operations have to be performed when inserting or erasing large number of records from the container. Lazy evaluation allows to hide destructive operations behind functional interface, and therefore help to counter this issue. Effectivness of this technique varies greatly, and depends on both internal structure of the container, as well it&#039;s current content. However, what remains constant is approach used in implementation of lazy evaluation in this library.</p><p>As already established in the Overview section, this library contains transactional variants of some of the data structures. Because transactional data structures form a wall isolating destructive changes, they can be used for the internal parts of the lazy evaluation style optimalization. Now, the other part of the recipe is to build functional interface around transactional instance. This essentially requires us to use to proxy objects that will fully adapt mutable interface into functional interface. Because of symetric design of the containers API, each destructive function has also functional counterpart. This makes the task fairly easy.</p><p>To translate functional API function calls into mutable calls, new class called LAZY-BOX-CONTAINER is introduced. LAZY-BOX-CONTAINER is holding the transactional instance of container alongside the CHANGES instance. All functional variants of API functions applicable to the internal instance, are applicable to the LAZY-BOX-CONTAINER instance as well and return values consinstent with the documentation. This is done by either manually implementing methods to work on LAZY-BOX-CONTAINER (this is the case for all query functions) or by intercepting internal low level mechanisms of position modification metaprotocol (the case for all modification functions). In other words, the LAZY-BOX-CONTAINER is (according to the design patterns terminology) a proxy. By implementing this interface, it is became possible to capture and enclose all modification calls in closures that can be executed later. Each time POSITION-MODIFICATION method for LAZY-BOX-CONTAINER is called new instance of the LAZY-BOX-CONTAINER with a additional closure (as well as a reference to the previous closures) and the isolated transactional instance is getting created and passed to the user. Now, the question arise: when it is required to call closures on the internal container?</p><p>The answer to this question is simple: cl-data-structures will call the closures only when user will query the state of the container. This will in turn destructivly change the internal container, however because of transactional semantics, changes will not leak outside. Finally, the query can be finished by forwarding call to freshly transformed internal container. At this point closures in the LAZY-BOX-CONTAINER can be discarded, as changes have been fully transfered to the state of the internal container. This creates the ilusion of fully functional interface, while minimizing the cost of copy-on-write procedure.</p><p>To summarise: lazy evaluation of the data structures is taken care of as long as transactional variant of data structure is available.</p></div></div></div></div>
</body>
</html>