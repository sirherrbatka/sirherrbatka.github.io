<!DOCTYPE html>
<html>
<head><meta charset="utf-8"><link rel="stylesheet" type="text/css" href="style.css"> <link href="https://fonts.googleapis.com/css?family=Inconsolata|Lato" rel="stylesheet"></head><body>
<div class="wrap"><div class="vertical-menu"><ul><li><a href="index.html#3190655339793870979">CL-DATA-STRUCTURES</a><ul><li><a href="l_1.html#1251961067911737300">Overview</a><ul><li><a href="l_1.html#4242817648129609900">Conventions</a></li><li><a href="l_1.html#2847245495541025479">Key concepts</a><ul><li><a href="l_1.html#2320887042715011554">Signaling errors</a></li><li><a href="l_1.html#4518039719649293500">Modification Status</a></li><li><a href="l_1.html#3643586353054251500">Trait classes</a></li><li><a href="l_1.html#1928765280294627127">Variants</a></li></ul></li></ul></li><li><a href="l_2.html#4222869598416573977">API Reference</a><ul><li><a href="l_2.html#1512150738849035350">Common API</a><ul><li><a href="l_2.html#938572120594180475">Generic Functions</a></li><li><a href="l_2.html#3612280545784207377">Macros</a></li><li><a href="l_2.html#2345823072029255325">Classes</a></li><li><a href="l_2.html#3400045302516649154">Conditions</a></li></ul></li></ul></li><li><a href="l_3.html#1305348342526909850">Algorithms Reference</a><ul><li><a href="l_3.html#489070044943620725">Aggregation Functions</a></li></ul></li><li><a href="l_4.html#4430135727726789600">File System Reference</a></li><li><a href="l_5.html#535180013938761100">Math Reference</a></li><li><a href="l_6.html#1544884125603864500">Internal details</a><ul><li><a href="l_6.html#3189372725119137379">Lazy evaluation</a></li><li><a href="l_6.html#43421450461843025">POSITION-MODIFICATION metaprotocol</a><ul><li><a href="l_6.html#3275516164848214625">Generic Functions</a></li><li><a href="l_6.html#3085070247397522479">Classes</a></li></ul></li><li><a href="l_6.html#166354786587511600">Aggregation algorithms metaprotocol</a></li></ul></li><li><a href="l_7.html#4108170023842651000">Dictionary structures</a><ul><li><a href="l_7.html#4429159259394941831">API</a></li><li><a href="l_7.html#4312713396213995500">HAMT</a><ul><li><a href="l_7.html#1238519961303936350">Constructing</a></li><li><a href="l_7.html#2467259150341889154">POSITION-MODIFICATION contracts</a></li></ul></li></ul></li></ul></li></ul></div><div class="content"><div id="1305348342526909850"><h2>Algorithms Reference
</h2><p>This section contains reference of all the functions in the CL-DS.ALG package. Majority of those functions are either layer functions or aggregation functions.</p><div id="489070044943620725"><h3>Aggregation Functions
</h3>Symbols in the package CL-DATA-STRUCTURES.ALGORITHMS:
<div class="function-info"><div class="doc-name">
ACCUMULATE
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(RANGE FN &amp;KEY KEY INITIAL-VALUE)
</div><b>Description:</b>
Like CL:REDUCE but works on all traversable objects.
<br></div><div class="function-info"><div class="doc-name">
HASH-JOIN
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(PRIMARY-RANGE PRIMARY-KEY SECONDARY-RANGE-FORMS &amp;KEY TEST JOIN-FUNCTION KEY)
</div><b>Examples:</b>
<pre><code>(LET ((RESULT
       (SORT
        (CL-DATA-STRUCTURES.ALGORITHMS:HASH-JOIN #(1 2 3 4) #&#039;IDENTITY
                                                 (LIST
                                                  (CL-DATA-STRUCTURES:FIELD
                                                   :DATA #(1 2 3) :KEY
                                                   #&#039;IDENTITY))
                                                 #&#039;&lt; :KEY #&#039;FIRST))))
  (PROVE.TEST:IS (LENGTH RESULT) 3)
  (MAP NIL (LAMBDA (X) (PROVE.TEST:IS (FIRST X) (SECOND X))) RESULT))</pre></code><br><b>Description:</b>
Joins multiple ranges using hash join algorithm.
<br><b>Returns:</b>
FORWARD-RANGE
<br></div><div class="function-info"><div class="doc-name">
COUNT-ELEMENTS
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(RANGE)
</div><b>Examples:</b>
<pre><code>(LET ((DATA #(1 2 3 4 5)))
  (PROVE.TEST:IS (LENGTH DATA)
                 (CL-DATA-STRUCTURES.ALGORITHMS:COUNT-ELEMENTS DATA))
  (PROVE.TEST:IS 3
                 (CL-DATA-STRUCTURES:AT
                  (CL-DATA-STRUCTURES.ALGORITHMS:COUNT-ELEMENTS
                   (CL-DATA-STRUCTURES.ALGORITHMS:GROUP-BY DATA :KEY #&#039;EVENP))
                  NIL)))</pre></code><br><b>Description:</b>
Counts number of elements. Usefull mostly in conjuction with GROUP-BY.
<br><b>Returns:</b>
Integer with count of elements.
<br><b>See also:</b>
<ul><li>GROUP-BY</li></ul><br></div><div class="macro-info"><div class="doc-name">
SUMMARY
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(RANGE &amp;BODY FUNCTIONS)
</div><b>Arguments:</b>
<ul><li>RANGE, Range to aggregate.</li><li>FORMS, Way to invoke function in the form of the plist. Key is a label used to identify value in the result range, second is aggregation function form (function and the function arguments). The range will be inserted as the first argument in the aggregation function call by default, or in the place of any symbol with name '_'.</li></ul><br><b>Description:</b>
Summary is a macro that allows to perform multiple aggregations in one form.
<br><b>Returns:</b>
Range of results. Use cl-ds:at with label to extract result of each individual aggregation form.
<br><b>Notes:</b>
Currently, this macro does support only the single stage aggregation functions.
<br></div><div class="function-info"><div class="doc-name">
EXTREMA
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(RANGE FN &amp;KEY KEY VALUE-KEY)
</div><b>Arguments:</b>
<ul><li>RANGE, Input range.</li><li>FN, Comparsion function.</li><li>KEY, Function used to extract values from the elements in the RANGE.</li><li>VALUE-KEY, Like KEY, but using this instead will preserve the complete element in the result. This argument can be used in combination with KEY, in which case KEY is applied before the VALUE-KEY.</li></ul><br><b>Description:</b>
Aggregation function. Find extrema (both minimum and maximum) in the RANGE, according to the FN comparsion function.
<br><b>Returns:</b>
Dotted pair. First value is the extremum that would occur as first element in the sequence sorted according to the FN, second value is the element that would occur last.
<br></div><div class="function-info"><div class="doc-name">
EXTREMUM
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(RANGE FN &amp;KEY KEY VALUE-KEY)
</div><b>Arguments:</b>
<ul><li>RANGE, Input range.</li><li>FN, Comparsion function.</li><li>KEY, Function used to extract values from the elements in the RANGE.</li><li>VALUE-KEY, Like KEY, but using this instead will preserve the complete element in the result. This argument can be used in combination with KEY, in which case KEY is applied before the VALUE-KEY.</li></ul><br><b>Description:</b>
Aggregation function. Find extremum (first value that would occur if whole range was sorted according to the FN). This can be used to find either the maximum or the minium.
<br><b>Returns:</b>
Extremum
<br></div><div class="function-info"><div class="doc-name">
EXTREMA
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(RANGE FN &amp;KEY KEY VALUE-KEY)
</div><b>Arguments:</b>
<ul><li>RANGE, Input range.</li><li>FN, Comparsion function.</li><li>KEY, Function used to extract values from the elements in the RANGE.</li><li>VALUE-KEY, Like KEY, but using this instead will preserve the complete element in the result. This argument can be used in combination with KEY, in which case KEY is applied before the VALUE-KEY.</li></ul><br><b>Description:</b>
Aggregation function. Find extrema (both minimum and maximum) in the RANGE, according to the FN comparsion function.
<br><b>Returns:</b>
Dotted pair. First value is the extremum that would occur as first element in the sequence sorted according to the FN, second value is the element that would occur last.
<br></div><div class="function-info"><div class="doc-name">
TO-VECTOR
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(RANGE &amp;KEY KEY ELEMENT-TYPE FORCE-COPY SIZE)
</div><b>Arguments:</b>
<ul><li>RANGE, Object to aggregate accross.</li><li>KEY, Key function used to extract value for vector.</li><li>ELEMENT-TYPE, :element-type for result vector.</li><li>SIZE, Initial size of internal vector. Supplied to optimize memory allocations.</li><li>FORCE-COPY, Pass NIL to allow returning vector passed as RANGE.</li></ul><br><b>Description:</b>
Collects all elements into CL:VECTOR.
<br><b>Returns:</b>
cl:vector with content of the range.
<br><b>Notes:</b>
<ul><li>There is no way to know ahead of time how large vector will be created, therefore multiple reallocations may be performed during aggregation. User can supply :SIZE to mitigate that.</li><li>To avoid copying in cases when RANGE is also a vector, pass nil as :force-copy.</li></ul><br></div></div></div></div></div>
</body>
</html>