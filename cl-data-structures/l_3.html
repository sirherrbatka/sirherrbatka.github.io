<!DOCTYPE html>
<html>
<head><meta charset="utf-8"><link rel="stylesheet" type="text/css" href="style.css"> <link href="https://fonts.googleapis.com/css?family=Inconsolata|Lato" rel="stylesheet"></head><body>
<div class="wrap"><div class="vertical-menu"><ul><li><a href="main.html#4027295039038115331">CL-DATA-STRUCTURES</a><ul><li><a href="l_1.html#3920997251579164900">Overview</a><ul><li><a href="l_1.html#2141295841218766050">Conventions</a></li><li><a href="l_1.html#3540820972188604331">Key concepts</a><ul><li><a href="l_1.html#283023268661035175">Signaling errors</a></li><li><a href="l_1.html#2756258029555992654">Modification Status</a></li><li><a href="l_1.html#969461507162169450">Trait classes</a></li><li><a href="l_1.html#1509330835118547350">Variants</a></li></ul></li></ul></li><li><a href="l_2.html#3703562457547459000">API Reference</a><ul><li><a href="l_2.html#83553826776506125">Meta level</a><ul><li><a href="l_2.html#2768286314186651379">Generic Functions</a></li><li><a href="l_2.html#608792041535272075">Classes</a></li></ul></li><li><a href="l_2.html#3827002299166816577">Common API</a><ul><li><a href="l_2.html#3850214645360678731">Generic Functions</a></li><li><a href="l_2.html#3133987488624321554">Macros</a></li><li><a href="l_2.html#1004541089597842225">Classes</a></li><li><a href="l_2.html#3551938551952971054">Conditions</a></li></ul></li></ul></li><li><a href="l_3.html#1050847759505388000">Internal details</a><ul><li><a href="l_3.html#3361718660377666879">Docstrings and docstample</a></li><li><a href="l_3.html#2448202317081021479">POSITION-MODIFICATION metaprotocol</a></li></ul></li><li><a href="l_4.html#3089425203579543400">Dictionary structures</a><ul><li><a href="l_4.html#3102895619044199554">API</a></li><li><a href="l_4.html#1067623572140447725">HAMT</a><ul><li><a href="l_4.html#4031158419032782054">Constructing</a></li><li><a href="l_4.html#1174962095674439477">POSITION-MODIFICATION contracts</a></li></ul></li></ul></li></ul></li></ul></div><div class="content"><div id="1050847759505388000"><h2>Internal details
</h2><p>This section explains parts of system design and low-level elements that shouldn&#039;t bother user of the library.  However, they are critical for contributors, and some people just want to know and so shall be delivered.</p><div id="3361718660377666879"><h3>Docstrings and docstample
</h3><p>Majority of docstrings are constructed and set outside function definitions, in a separate file. This has been done in such way to not clutter the code with information that is easy to obtain by any SLIME user. Furthermore this allows to build doctsrings with the code itself. This makes easier to ensure common, uniform style of docstrings. It may also perform various operations on docstrings. To handle this, a separate project called docstample was created. Hopefully, this tool can be augmented in the future to handle tasks such as automatic validation of examples. This is in fact what is done in this project. Examples are written as unit tests, so they can be checked if they actually work (so users are not getting angry, hopefully). Also, building docstrings from structured input eliminates need for parsing (a language other than lisp itself) to build a nicely formatted output (which is nice).</p></div><div id="2448202317081021479"><h3>POSITION-MODIFICATION metaprotocol
</h3><p>The package defines its own internal object protocol that is used to build parts of user API responsible for container modifications. This concept is nicknamed position-modification metaprotocol and is described in this section.</p><p>As every object protocol, position-modification metaprotocol consists of classes and generic functions that are expected to be implemented for said classes. Those functions are designed to peform low level (that is: dependent on the internals structure) operations on containers. For instance, those operations include manipulations (and construction) of buckets (and &quot;bucket&quot; is obviously low level term used in description of data structure).</p><p>Layer as a whole, derive it&#039;s name from one particular generic function called POSITION-MODIFICATION. It acts as a point of implementation for all functionality releated to modification of containers and therefore is called directly by functions like INSERT. Methods implementing POSITION-MODIFICATION act by calling other functions of this protocol.</p><img src="1.svg" class="centered">
<p>POSITION-MODIFICATION accepts OPERATION as a first argument. OPERATION is object of one of protocol classes FUNCTIONAL-FUNCTION or DESTRUCTIVE-FUNCTION. Objects of those classes include generic functions defined as part of the API. This is made possible by the fact that Generic Functions in Common Lisp are in fact objects of their own classes. In addition to those fundamental classes, protocol contains additional trait classes like for instance the GROW-FUNCTION. Because of this, it is possible to query API functions for expected behavior. It also makes possible to write methods that dispatch on behavior of the API functions. These include (as already established) bucket manipulation functions: SHRINK-BUCKET, GROW-BUCKET, MAKE-BUCKET.</p><p>Because all of those functions are generic ; and just like POSITION-MODIFICATION they accept OPERATION argument, it is possible to dispatch bucket modification logic, based on the class of the API function. Employing this approach allows to remove code duplication between various types of modification functions, and therefore reduce the burden of supporting functions like ERASE-IF in the codebase. Furthermore, establishing this protocol allows to alter standard behavior of buckets, and by that, create nested data structures.</p><p>Nested data structures are nontrivial problem, when immutable behavior is expected. Because eventual copy-on-write has to happen on two levels, It is essential to be able to intercept logic at the lower level of data structure. Luckly, as described, Common Lisp offers tools that allowed us to build elegant solution for such problem.</p></div></div></div></div>
</body>
</html>