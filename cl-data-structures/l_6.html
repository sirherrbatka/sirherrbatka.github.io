<!DOCTYPE html>
<html>
<head><meta charset="utf-8"><link rel="stylesheet" type="text/css" href="style.css"> <link href="https://fonts.googleapis.com/css?family=Inconsolata|Lato" rel="stylesheet"></head><body>
<div class="wrap"><div class="vertical-menu"><ul><li><a href="main.html#1503410024053259727">CL-DATA-STRUCTURES</a><ul><li><a href="l_1.html#4061737434083803831">Overview</a><ul><li><a href="l_1.html#1458180674752216677">Conventions</a></li><li><a href="l_1.html#2043886027951922700">Key concepts</a><ul><li><a href="l_1.html#4436260845017829100">Signaling errors</a></li><li><a href="l_1.html#2025489304321519400">Modification Status</a></li><li><a href="l_1.html#1741749048851807777">Trait classes</a></li><li><a href="l_1.html#1105787623997321200">Variants</a></li></ul></li></ul></li><li><a href="l_2.html#1725734609364986350">API Reference</a><ul><li><a href="l_2.html#2682181940406393100">Common API</a><ul><li><a href="l_2.html#3326694428259331025">Generic Functions</a></li><li><a href="l_2.html#4557399027619760400">Macros</a></li><li><a href="l_2.html#2775785563315652879">Classes</a></li><li><a href="l_2.html#3085199441087648300">Conditions</a></li></ul></li></ul></li><li><a href="l_3.html#2823426008474668025">Algorithms Reference</a><ul><li><a href="l_3.html#1768619729006467350">Aggregation Functions</a></li><li><a href="l_3.html#1386195837393241877">Layer Functions</a></li><li><a href="l_3.html#3089062636398721125">Other Functions</a></li></ul></li><li><a href="l_4.html#4138934074674891377">File System Reference</a></li><li><a href="l_5.html#4315402600868319031">Math Reference</a></li><li><a href="l_6.html#3029344193436291579">Clustering Reference</a></li><li><a href="l_7.html#3393923180965301400">Threads Reference</a></li><li><a href="l_8.html#92228291701679250">Streaming Algorithms Reference</a></li><li><a href="l_9.html#3926533812321216200">Dictionary structures</a><ul><li><a href="l_9.html#4471097175538015431">API</a></li><li><a href="l_9.html#21270614026110475">HAMT</a><ul><li><a href="l_9.html#4233493381495492400">Constructing</a></li><li><a href="l_9.html#1375522940289506127">POSITION-MODIFICATION contracts</a></li></ul></li><li><a href="l_9.html#2999850735665312100">Sparse RRB Vector</a></li></ul></li><li><a href="l_10.html#3571769152563963000">Internal details</a><ul><li><a href="l_10.html#3090019743017980500">Lazy evaluation</a></li><li><a href="l_10.html#4522144046235748400">POSITION-MODIFICATION metaprotocol</a><ul><li><a href="l_10.html#3890274177956192000">Generic Functions</a></li><li><a href="l_10.html#1746583554239001077">Classes</a></li></ul></li><li><a href="l_10.html#3835297338090773100">Aggregation algorithms metaprotocol</a></li></ul></li></ul></li></ul></div><div class="content"><div id="3029344193436291579"><h2>Clustering Reference
</h2><p>This section contains reference of all functions and classes in the CL-DS.CLUSTER package.</p>Symbols in the package CL-DATA-STRUCTURES.CLUSTERING:
<div class="generic-info"><div class="doc-name">
CLARA
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(RANGE NUMBER-OF-MEDOIDS SAMPLE-SIZE SAMPLE-COUNT METRIC-FN &amp;KEY KEY
 SELECT-MEDOIDS-ATTEMPTS-COUNT ATTEMPTS SPLIT MERGE)
</div><div class="doc-paragraph">Arguments:
 --RANGE, Data to cluster.
 --NUMBER-OF-MEDOIDS, How many clusters should be created?
 --SAMPLE-SIZE, Size of sample used to cluster data.
 --SAMPLE-COUNT, Number of samples that will be drawn.
 --METRIC-FN, Distance function used for clustering.
 --METRIC-TYPE, Type returned by METRIC-FN.
 --KEY, Function used to extract value for metric-fn.
 --SELECT-MEDOIDS-ATTEMPTS-COUNT, How many times PAM should attempt to select medoids before accepting suboptimal medoids?
 --ATTEMPTS, How many times clusters should be splitted and merged before accepting suboptimal cluster sizes.
 --SPLIT, Threshold size of clusters. Function will attempt to split clusters above this size.
 --MERGE, Threshold size of clusters. Function will attempt to merge clusters below this size.

Description:
 Clusters data set using CLARA algorithm. This algorithm attempts to cluster random subset, picking the best set of clusters.

Returns:
 Clusters object. Clusters itself are represented as a vector of vectors and can be read using CLUSTER-CONTENTS function. Additionally, silhouette values can be read with SILHOUETTE function.

Thread Safety:
 Uses lparallel underneath.

Notes:
 --Useful for clustering large data sets, as required memory is linear to the size of the data set and quadratic to the size of the sample.
 --Algorithm initially described in the Clustering Large Applications article.</div></div><div class="generic-info"><div class="doc-name">
K-MEANS
</div><div class="doc-lambda-list"><b>Lambda List:</b>
(RANGE NUMBER-OF-MEDOIDS DISTORTION-EPSILON &amp;REST ALL &amp;KEY KEY
 SILHOUETTE-SAMPLE-SIZE ITERATIONS SILHOUETTE-SAMPLE-COUNT)
</div><div class="doc-paragraph">Description:
 Clusters data set using k-means algorithm. Data points must be represented as one dimensional SIMPLE-ARRAYS specialized for SINGLE-FLOATS.

Returns:
 Clusters object. Clusters itself are represented as a vector of vectors and can be read using CLUSTER-CONTENTS function. Additionally, silhouette values can be read with SILHOUETTE function.

Exceptional situations:
 --Will signal a TYPE-ERROR when key does not return (SIMPLE-ARRAY &#039;SINGLE-FLOAT (*)).
 --Will signal a TYPE-ERROR when KEY is not funcallable.
 --Will signal a TYPE-ERROR when DISTORTION-EPSILON is not SINGLE-FLOAT.
 --Will signal a TYPE-ERROR when SILHOUETTE-SAMPLE-SIZE or SILHOUETTE-SAMPLE-COUNT is not of the INTEGER type.
 --sILHOUETTE-SAMPLE-SIZE and SILHOUETTE-SAMPLE-COUNT are supposed to have positive value. Otherwise ARGUMENT-OUT-OF-BOUNDS will be signalled.

Thread Safety:
 Uses lparallel underneath.

Notes:
 This algorithm does not calculate silhouette during it&#039;s operation and because of that calling silhouette on the result will take extra time.</div></div></div></div></div>
</body>
</html>